from typing import TypeVar, List, Union, Tuple
from copy import deepcopy

from sqlalchemy import and_, select, or_, inspect, Table
from sqlalchemy.sql import Subquery
from sqlalchemy.orm import declarative_base
from sqlalchemy.sql.elements import BinaryExpression
from pydantic import BaseModel

{{ import }}

Base = TypeVar("Base", bound=declarative_base)

OriginalStmt = TypeVar("OriginalStmt", bound=BinaryExpression)
SubQuery = TypeVar("SubQuery", bound=BinaryExpression)


def build_foreign_mapper(model):
    foreign_key_table = {}
    mapper = inspect(model)
    for r in mapper.relationships:
        local, = r.local_columns
        local = mapper.get_property_by_column(local).expression
        local_table = str(local).split('.')[0]
        local_column = str(local).split('.')[1]
        local_table_instance = local.table

        foreign_table = r.mapper.class_
        foreign_table_name = foreign_table.__tablename__
        foreign_secondary_table_name = ''
        if r.secondary_synchronize_pairs:
            # foreign_table_name = r.secondary.key
            foreign_secondary_table_name = str(r.secondary.key)

        local_reference_pairs = []
        for i in r.synchronize_pairs:
            for column in i:
                table_name_ = str(column).split('.')[0]
                column_name_ = str(column).split('.')[1]
                if table_name_ not in [foreign_secondary_table_name, foreign_table_name]:
                    continue

                reference_table = table_name_
                reference_column = column_name_
                reference_table_instance = column.table
                if r.secondary_synchronize_pairs:
                    exclude = True
                else:

                    exclude = False
                local_reference_pairs.append({'local': {"local_table": local_table,
                                                        "local_column": local_column},
                                              "reference": {"reference_table": reference_table,
                                                            "reference_column": reference_column},
                                              'local_table': local_table_instance,
                                              'local_table_columns': local_table_instance.c,
                                              'reference_table': reference_table_instance,
                                              'reference_table_columns': reference_table_instance.c,
                                              'exclude': exclude})
        for i in r.secondary_synchronize_pairs:
            local_table_: str = None
            local_column_: str = None
            reference_table_: str = None
            reference_column_: str = None
            local_table_instance_: Table = None
            reference_table_instance_: Table = None
            for column in i:

                table_name_ = str(column).split('.')[0]
                column_name_ = str(column).split('.')[1]
                if table_name_ == foreign_secondary_table_name:
                    local_table_ = str(column).split('.')[0]
                    local_column_ = str(column).split('.')[1]
                    local_table_instance_ = column.table
                if table_name_ == foreign_table_name:
                    reference_table_ = str(column).split('.')[0]
                    reference_column_ = str(column).split('.')[1]
                    reference_table_instance_ = column.table

            local_reference_pairs.append({'local': {"local_table": local_table_,
                                                    "local_column": local_column_},
                                          "reference": {"reference_table": reference_table_,
                                                        "reference_column": reference_column_},
                                          'local_table': local_table_instance_,
                                          'local_table_columns': local_table_instance_.c,
                                          'reference_table': reference_table_instance_,
                                          'reference_table_columns': reference_table_instance_.c,
                                          'exclude': False})

        foreign_key_table[foreign_table_name] = {'local_reference_pairs_set': local_reference_pairs,
                                                 'instance': foreign_table,
                                                 'db_column': foreign_table}
    return foreign_key_table


def orderby_expression_builder(stmt, order_by_columns, model):
    if not order_by_columns:
        return stmt
    order_by_query_list = []

    for order_by_column in order_by_columns:
        if not order_by_column:
            continue
        sort_column, order_by = (order_by_column.replace(' ', '').split(':') + [None])[:2]
        if not hasattr(model, sort_column):
            raise UnknownColumn(400, f'Column {sort_column} is not existed')
        if not order_by:
            order_by_query_list.append(getattr(model, sort_column).asc())
        elif order_by.upper() == Ordering.DESC.upper():
            order_by_query_list.append(getattr(model, sort_column).desc())
        elif order_by.upper() == Ordering.ASC.upper():
            order_by_query_list.append(getattr(model, sort_column).asc())
        else:
            raise UnknownOrderType(400, f"Unknown order type {order_by}, only accept DESC or ASC")
    if order_by_query_list:
        stmt = stmt.order_by(*order_by_query_list)
    return stmt


def join_expression_builder(stmt: BinaryExpression, join_table_dict, parent_table) -> Tuple[OriginalStmt, SubQuery]:
    if not join_table_dict:
        return stmt, None

    foreign_column_list = relationship_query_builder(join_table_dict)

    original_query = stmt.subquery()
    query_set = original_query.c._all_columns + foreign_column_list

    nested_query = select(query_set)
    for _, foreign_table_mapper in join_table_dict.items():
        for local_reference in foreign_table_mapper['local_reference_pairs_set']:
            if 'exclude' in local_reference and local_reference['exclude']:
                continue
            foreign_table = local_reference["reference_table"]
            nested_query = nested_query.join(foreign_table, getattr(original_query.c, local_reference["local"][
                "local_column"]) == getattr(foreign_table.c, local_reference["reference"]["reference_column"]),
                                             isouter=True)

    return nested_query, original_query


def group_find_many_join(result, group_by_columns: List[str]) -> List[dict]:

    response_data_list = []
    for i in result:
        temp = {}
        result = deepcopy(dict(i))
        for key_, value_ in result.items():
            # if query with foreign key
            if 'relationship__' in key_:
                key_ = key_.replace("relationship__", "")
                foreign_table, foreign_column = key_.split('_._')
                if foreign_table not in temp:
                    temp[foreign_table] = {foreign_column: value_}
                else:
                    temp[foreign_table][foreign_column] = value_
            else:
                temp[key_] = value_
        response_data_list.append(temp)

    response_list = []
    group_by = groupby(response_data_list, key=operator.itemgetter(*group_by_columns))
    for key, group in group_by:
        group_by_dict = {}
        relationship = {}
        for i in group:
            for k, v in i.items():
                if k in group_by_columns:
                    group_by_dict[k] = v
                else:
                    if k not in relationship:
                        relationship[k] = [v]
                    else:
                        relationship[k].append(v)
        response_list.append({**group_by_dict, "relationship": {**relationship}})

    return response_list

def relationship_query_builder(join_table_dict):
    foreign_column_list = []
    if join_table_dict:
        # foreign_model_list = [getattr(model, str(foreign_table))for foreign_table in join_table_list]
        for _, table_instance in join_table_dict.items():
            for local_reference in table_instance['local_reference_pairs_set']:
                if 'exclude' in local_reference and local_reference['exclude']:
                    continue
                for column in local_reference['reference_table_columns']:
                    foreign_column_list.append(column.label(
                        "relationship__" + str(column).split('.')[0] + "_._" + str(column).split('.')[1]))
    return foreign_column_list

def find_query_builder(param: dict, model: Base) -> List[Union[BinaryExpression]]:
    query = []
    for column_name, value in param.items():
        if ExtraFieldType.Comparison_operator in column_name or ExtraFieldType.Matching_pattern in column_name:
            continue
        if ExtraFieldTypePrefix.List in column_name:
            type_ = ExtraFieldTypePrefix.List
        elif ExtraFieldTypePrefix.From in column_name:
            type_ = ExtraFieldTypePrefix.From
        elif ExtraFieldTypePrefix.To in column_name:
            type_ = ExtraFieldTypePrefix.To
        elif ExtraFieldTypePrefix.Str in column_name:
            type_ = ExtraFieldTypePrefix.Str
        else:
            query.append((getattr(model, column_name) == value))
            # raise Exception('known error')
            continue
        sub_query = []
        table_column_name = column_name.replace(type_, "")
        operator_column_name = column_name + process_type_map[type_]
        operators = param.get(operator_column_name, None)
        if not operators:
            raise QueryOperatorNotFound(400, f'The query operator of {column_name} not found!')
        if not isinstance(operators, list):
            operators = [operators]
        for operator in operators:
            sub_query.append(process_map[operator](getattr(model, table_column_name), value))
        query.append((or_(*sub_query)))
    return query


def value_of_list_to_str(request_or_response_object, columns):
    received_request = deepcopy(request_or_response_object.__dict__)
    if isinstance(columns, str):
        columns = [columns]
    if 'insert' in request_or_response_object.__dict__:
        insert_str_list = []
        for insert_item in request_or_response_object.__dict__['insert']:
            for column in columns:
                for insert_item_column, _ in insert_item.__dict__.items():
                    if column in insert_item_column:
                        value_ = insert_item.__dict__[insert_item_column]
                        if value_ is not None:
                            if isinstance(value_, list):
                                str_value_ = [str(i) for i in value_]
                            else:
                                str_value_ = str(value_)
                            setattr(insert_item, insert_item_column, str_value_)
            insert_str_list.append(insert_item)
        setattr(request_or_response_object, 'insert', insert_str_list)
    else:
        for column in columns:
            for received_column_name, _ in received_request.items():
                if column in received_column_name:
                    value_ = received_request[received_column_name]
                    if value_ is not None:
                        if isinstance(value_, list):
                            str_value_ = [str(i) for i in value_]
                        else:
                            str_value_ = str(value_)
                        setattr(request_or_response_object, received_column_name, str_value_)


def filter_none(request_or_response_object):
    received_request = deepcopy(request_or_response_object.__dict__)
    if 'insert' in received_request:
        insert_item_without_null = []
        for received_insert in received_request['insert']:
            received_insert_ = deepcopy(received_insert)
            for received_insert_item, received_insert_value in received_insert_.__dict__.items():
                if hasattr(received_insert_value, '__module__'):
                    if received_insert_value.__module__ == 'fastapi.params' or received_insert_value is None:
                        delattr(received_insert, received_insert_item)
                elif received_insert_value is None:
                    delattr(received_insert, received_insert_item)

            insert_item_without_null.append(received_insert)
        setattr(request_or_response_object, 'insert', insert_item_without_null)
    else:
        for name, value in received_request.items():
            if hasattr(value, '__module__'):
                if value.__module__ == 'fastapi.params' or value is None:
                    delattr(request_or_response_object, name)
            elif value is None:
                delattr(request_or_response_object, name)

class ExcludeUnsetBaseModel(BaseModel):
    def dict(self, *args, **kwargs):
        if kwargs and kwargs.get("exclude_none") is not None:
            kwargs["exclude_unset"] = True
            return BaseModel.dict(self, *args, **kwargs)

def clean_input_fields(param: Union[dict, list], model: Base):
    assert isinstance(param, dict) or isinstance(param, list) or isinstance(param, set)

    if isinstance(param, dict):
        stmt = {}
        for column_name, value in param.items():
            if '_initialised__' in column_name:
                continue
            column = getattr(model, column_name)
            actual_column_name = column.expression.key
            stmt[actual_column_name] = value
        return stmt
    if isinstance(param, list) or isinstance(param, set):
        stmt = []
        for column_name in param:
            if not hasattr(model, column_name):
                raise UnknownColumn(400,f'Column {column_name} is not existed')
            column = getattr(model, column_name)
            actual_column_name = column.expression.key
            stmt.append(actual_column_name)
        return stmt