from typing import TypeVar, List, Union, Tuple, Dict
from copy import deepcopy

from sqlalchemy import and_, select, or_, inspect, Table, Table, Column
from sqlalchemy.sql import Subquery
from sqlalchemy.orm import declarative_base, decl_api
from sqlalchemy.sql.elements import BinaryExpression
from pydantic import BaseModel


{{ import }}

Base = TypeVar("Base", bound=declarative_base)

FOREIGN_PATH_PARAM_KEYWORD = "__pk__"

OriginalStmt = TypeVar("OriginalStmt", bound=BinaryExpression)
SubQuery = TypeVar("SubQuery", bound=BinaryExpression)
PrimaryColumn = TypeVar("PrimaryColumn", bound=Column)


def remove_unnecessary_table(model, relationship_mapper, join_table_list):
    excluded_table = [model.__tablename__, *join_table_list]
    for k, v in relationship_mapper.items():
        tmp = []
        for local_reference in v["local_reference_pairs_set"]:
            if local_reference["local"]["table"] not in excluded_table:
                continue
            tmp.append(local_reference)
        relationship_mapper[k]["local_reference_pairs_set"] = tmp
    return relationship_mapper


def build_foreign_key_table(models: List[decl_api.DeclarativeMeta]) -> dict:
    foreign_key_table = {}

    for k in models:
        foreign_key_table[k.__tablename__] = build_foreign_mapper(k)
    tmp = deepcopy(foreign_key_table)
    for k_1, v_1 in tmp.items():
        for relationships_table, relationships_pairs in v_1.items():
            relationships_pairs_list = relationships_pairs["local_reference_pairs_set"]
            for pair_dict in relationships_pairs_list:
                reference_table = pair_dict["reference"]["table"]
                if reference_table in foreign_key_table:
                    for nested_relationship in foreign_key_table[reference_table]:
                        if nested_relationship not in foreign_key_table[k_1]:
                            foreign_key_table[k_1][nested_relationship] = foreign_key_table[reference_table][nested_relationship]

    return foreign_key_table


def build_relationship_mapper(foreign_key_table, join_table_name) -> dict:
    relationship_mapper = {}
    if foreign_key_table is None:
        return relationship_mapper
    for table_name, mapper in foreign_key_table.items():
        if table_name == join_table_name:
            relationship_mapper[table_name] = mapper
    return relationship_mapper


def get_pk(model: decl_api.DeclarativeMeta) -> PrimaryColumn:
    pk, = model.__table__.primary_key
    return pk


def build_foreign_mapper(model: decl_api.DeclarativeMeta):
    foreign_key_table = {}
    mapper = inspect(model)
    for r in mapper.relationships:
        local, = r.local_columns
        local = mapper.get_property_by_column(local).expression
        local_table = str(local).split('.')[0]
        local_column = str(local).split('.')[1]
        local_table_instance = local.table

        foreign_table = r.mapper.class_
        foreign_table_name = foreign_table.__tablename__
        foreign_secondary_table_name = ''
        if r.secondary_synchronize_pairs:
            # foreign_table_name = r.secondary.key
            foreign_secondary_table_name = str(r.secondary.key)

        local_reference_pairs = []
        for i in r.synchronize_pairs:
            for column in i:
                table_name_ = str(column).split('.')[0]
                column_name_ = str(column).split('.')[1]
                if table_name_ not in [foreign_secondary_table_name, foreign_table_name]:
                    continue

                reference_table = table_name_
                reference_column = column_name_
                reference_table_instance = column.table
                if r.secondary_synchronize_pairs:
                    exclude = True
                else:

                    exclude = False
                local_reference_pairs.append({'local': {"table": local_table,
                                                        "column": local_column},
                                              "reference": {"table": reference_table,
                                                            "column": reference_column},
                                              'local_table': local_table_instance,
                                              'local_table_columns': local_table_instance.c,
                                              'reference_table': reference_table_instance,
                                              'reference_table_columns': reference_table_instance.c,
                                              'exclude': exclude})
        for i in r.secondary_synchronize_pairs:
            local_table_: str = None
            local_column_: str = None
            reference_table_: str = None
            reference_column_: str = None
            local_table_instance_: Table = None
            reference_table_instance_: Table = None
            for column in i:

                table_name_ = str(column).split('.')[0]
                column_name_ = str(column).split('.')[1]
                if table_name_ == foreign_secondary_table_name:
                    local_table_ = str(column).split('.')[0]
                    local_column_ = str(column).split('.')[1]
                    local_table_instance_ = column.table
                if table_name_ == foreign_table_name:
                    reference_table_ = str(column).split('.')[0]
                    reference_column_ = str(column).split('.')[1]
                    reference_table_instance_ = column.table

            local_reference_pairs.append({'local': {"table": local_table_,
                                                    "column": local_column_},
                                          "reference": {"table": reference_table_,
                                                        "column": reference_column_},
                                          'local_table': local_table_instance_,
                                          'local_table_columns': local_table_instance_.c,
                                          'reference_table': reference_table_instance_,
                                          'reference_table_columns': reference_table_instance_.c,
                                          'exclude': False})

        foreign_key_table[foreign_table_name] = {'local_reference_pairs_set': local_reference_pairs,
                                                 'instance': foreign_table,
                                                 'db_column': foreign_table}
    return foreign_key_table


def join_relationship_mapping_builder(relationship_mapper: dict, target_model: str, join_table_list: List[str]):
    join_list = {}
    for _, foreign_table_mappers in relationship_mapper.items():
        for foreign_table_name, foreign_table_mapper in foreign_table_mappers.items():
            if foreign_table_name != target_model:
                foreign_table_mapper["join"] = False
                if foreign_table_name in join_table_list:
                    foreign_table_mapper["join"] = True
                join_list[foreign_table_name] = foreign_table_mapper
    return join_list


def orderby_expression_builder(stmt, order_by_columns, model):
    if not order_by_columns:
        return stmt
    order_by_query_list = []

    for order_by_column in order_by_columns:
        if not order_by_column:
            continue
        sort_column, order_by = (order_by_column.replace(' ', '').split(':') + [None])[:2]
        if not hasattr(model, sort_column):
            raise UnknownColumn(400, f'Column {sort_column} is not existed')
        if not order_by:
            order_by_query_list.append(getattr(model, sort_column).asc())
        elif order_by.upper() == Ordering.DESC.upper():
            order_by_query_list.append(getattr(model, sort_column).desc())
        elif order_by.upper() == Ordering.ASC.upper():
            order_by_query_list.append(getattr(model, sort_column).asc())
        else:
            raise UnknownOrderType(400, f"Unknown order type {order_by}, only accept DESC or ASC")
    if order_by_query_list:
        stmt = stmt.order_by(*order_by_query_list)
    return stmt


def join_expression_builder(stmt: BinaryExpression, join_relationship_mapping: dict, base_table_dict: Dict[Table, SubQuery] = None) -> Tuple[OriginalStmt, SubQuery]:
    if base_table_dict is None:
        base_table_dict = {}
    if join_relationship_mapping is None:
        return stmt

    for join_table_name, join_table in join_relationship_mapping.items():

        if join_table["join"] is not True:
            continue

        for local_reference in join_table['local_reference_pairs_set']:

            if 'exclude' in local_reference and local_reference['exclude']:
                continue
            foreign_table = local_reference["reference_table"]
            local_table = local_reference["local_table"]
            # handle subquery
            if local_table in base_table_dict:
                local_table = base_table_dict[local_table]
            stmt = stmt.join(foreign_table, getattr(local_table.c, local_reference["local"][
                "column"]) == getattr(foreign_table.c, local_reference["reference"]["column"]),
                             isouter=True)

    return stmt


def group_find_many_join(result, group_by_columns: List[str]) -> List[dict]:

    response_data_list = []
    for i in result:
        temp = {}
        result = deepcopy(dict(i))
        for key_, value_ in result.items():
            # if query with foreign key
            if 'relationship__' in key_:
                key_ = key_.replace("relationship__", "")
                foreign_table, foreign_column = key_.split('_._')
                if foreign_table not in temp:
                    temp[foreign_table] = {foreign_column: value_}
                else:
                    temp[foreign_table][foreign_column] = value_
            else:
                temp[key_] = value_
        response_data_list.append(temp)

    response_list = []
    group_by = groupby(response_data_list, key=operator.itemgetter(*group_by_columns))
    for key, group_of_aggr in group_by:
        group_by_dict = {}
        relationship = {}
        for items in group_of_aggr:
            for column_name, column_value in items.items():
                if column_name in group_by_columns:
                    group_by_dict[column_name] = column_value
                else:
                    is_all_null = all(v is None for _, v in column_value.items())

                    if column_name not in relationship:
                        relationship[column_name] = []
                    if not is_all_null:
                        relationship[column_name].append(column_value)
        response_list.append({**group_by_dict, "relationship": {**relationship}})

    return response_list


def relationship_query_builder(join_table_dict):
    foreign_column_list = []
    for _, table_instance in join_table_dict.items():
        if table_instance["join"] is not True:
            continue
        for local_reference in table_instance['local_reference_pairs_set']:
            if 'exclude' in local_reference and local_reference['exclude']:
                continue
            for column in local_reference['reference_table_columns']:
                foreign_column_list.append(column.label(
                    "relationship__" + str(column).split('.')[0] + "_._" + str(column).split('.')[1]))
    return foreign_column_list


def find_query_builder(param: dict, model: Base) -> List[Union[BinaryExpression]]:
    query = []
    for column_name, value in param.items():
        if ExtraFieldType.Comparison_operator in column_name or ExtraFieldType.Matching_pattern in column_name:
            continue
        if ExtraFieldTypePrefix.List in column_name:
            type_ = ExtraFieldTypePrefix.List
        elif ExtraFieldTypePrefix.From in column_name:
            type_ = ExtraFieldTypePrefix.From
        elif ExtraFieldTypePrefix.To in column_name:
            type_ = ExtraFieldTypePrefix.To
        elif ExtraFieldTypePrefix.Str in column_name:
            type_ = ExtraFieldTypePrefix.Str
        else:
            query.append((getattr(model, column_name) == value))
            # raise Exception('known error')
            continue
        sub_query = []
        table_column_name = column_name.replace(type_, "")
        operator_column_name = column_name + process_type_map[type_]
        operators = param.get(operator_column_name, None)
        if not operators:
            raise QueryOperatorNotFound(400, f'The query operator of {column_name} not found!')
        if not isinstance(operators, list):
            operators = [operators]
        for operator in operators:
            sub_query.append(process_map[operator](getattr(model, table_column_name), value))
        query.append((or_(*sub_query)))
    return query


def value_of_list_to_str(request_or_response_object, columns):
    received_request = deepcopy(request_or_response_object.__dict__)
    if isinstance(columns, str):
        columns = [columns]
    if 'insert' in request_or_response_object.__dict__:
        insert_str_list = []
        for insert_item in request_or_response_object.__dict__['insert']:
            for column in columns:
                for insert_item_column, _ in insert_item.__dict__.items():
                    if column in insert_item_column:
                        value_ = insert_item.__dict__[insert_item_column]
                        if value_ is not None:
                            if isinstance(value_, list):
                                str_value_ = [str(i) for i in value_]
                            else:
                                str_value_ = str(value_)
                            setattr(insert_item, insert_item_column, str_value_)
            insert_str_list.append(insert_item)
        setattr(request_or_response_object, 'insert', insert_str_list)
    else:
        for column in columns:
            for received_column_name, _ in received_request.items():
                if column in received_column_name:
                    value_ = received_request[received_column_name]
                    if value_ is not None:
                        if isinstance(value_, list):
                            str_value_ = [str(i) for i in value_]
                        else:
                            str_value_ = str(value_)
                        setattr(request_or_response_object, received_column_name, str_value_)


def filter_none(request_or_response_object):
    received_request = deepcopy(request_or_response_object.__dict__)
    if 'insert' in received_request:
        insert_item_without_null = []
        for received_insert in received_request['insert']:
            received_insert_ = deepcopy(received_insert)
            for received_insert_item, received_insert_value in received_insert_.__dict__.items():
                if hasattr(received_insert_value, '__module__'):
                    if received_insert_value.__module__ == 'fastapi.params' or received_insert_value is None:
                        delattr(received_insert, received_insert_item)
                elif received_insert_value is None:
                    delattr(received_insert, received_insert_item)

            insert_item_without_null.append(received_insert)
        setattr(request_or_response_object, 'insert', insert_item_without_null)
    else:
        for name, value in received_request.items():
            if hasattr(value, '__module__'):
                if value.__module__ == 'fastapi.params' or value is None:
                    delattr(request_or_response_object, name)
            elif value is None:
                delattr(request_or_response_object, name)

class ExcludeUnsetBaseModel(BaseModel):
    def dict(self, *args, **kwargs):
        if kwargs and kwargs.get("exclude_none") is not None:
            kwargs["exclude_unset"] = True
            return BaseModel.dict(self, *args, **kwargs)

def clean_input_fields(param: Union[dict, list], model: Base):
    assert isinstance(param, dict) or isinstance(param, list) or isinstance(param, set)

    if isinstance(param, dict):
        stmt = {}
        for column_name, value in param.items():
            if '_initialised__' in column_name:
                continue
            column = getattr(model, column_name)
            actual_column_name = column.expression.key
            stmt[actual_column_name] = value
        return stmt
    if isinstance(param, list) or isinstance(param, set):
        stmt = []
        for column_name in param:
            if not hasattr(model, column_name):
                raise UnknownColumn(400,f'Column {column_name} is not existed')
            column = getattr(model, column_name)
            actual_column_name = column.expression.key
            stmt.append(actual_column_name)
        return stmt


def foreign_path_query_builder(param, model) -> List[Union[BinaryExpression]]:
    query = []
    if not param:
        return query
    for param_name, param_value in param.items():
        table_with_column = param_name.split(FOREIGN_PATH_PARAM_KEYWORD)
        assert len(table_with_column) == 2
        table_name, column_name = table_with_column
        table_model = model[table_name]
        query.append((getattr(table_model, column_name) == param_value))
    return query
